var documenterSearchIndex = {"docs":
[{"location":"forestmensuration/#ForestMensuration-Package:","page":"ForestMensuration Package","title":"ForestMensuration Package:","text":"","category":"section"},{"location":"forestmensuration/","page":"ForestMensuration Package","title":"ForestMensuration Package","text":"Documentation for ForestMensuration.","category":"page"},{"location":"forestmensuration/","page":"ForestMensuration Package","title":"ForestMensuration Package","text":"ForestMensuration.jl is a Julia package that offers a comprehensive suite of functions for dendrometric calculations. With a focus on simplicity and efficiency, it streamlines complex forestry computations through an intuitive interface. Key features include:","category":"page"},{"location":"forestmensuration/","page":"ForestMensuration Package","title":"ForestMensuration Package","text":"Regression Analysis: Seamlessly fit linear models—complete with variable transformations and handling of categorical data—to uncover the best relationships in your forestry datasets.\nTree and Stand Volume Estimation: Accurately compute tree and stand volumes using a range of methods, including Huber, Smalian, and Newton techniques.\nSite Productivity Classification: Implement advanced methods to evaluate and classify the productivity and quality of forest sites.\nDendrometric Averaging: Easily calculate essential metrics such as mean diameter, quadratic mean diameter, and other averages to analyze stand structure.\nFrequency and Diametric Tables: Generate detailed frequency and diameter distribution tables to support comprehensive data analysis.","category":"page"},{"location":"forestmensuration/","page":"ForestMensuration Package","title":"ForestMensuration Package","text":"Whether you are conducting research or managing forestry operations, ForestMensuration.jl simplifies the process of analyzing dendrometric data, enabling you to perform sophisticated calculations with minimal effort.","category":"page"},{"location":"forestmensuration/","page":"ForestMensuration Package","title":"ForestMensuration Package","text":"CurrentModule = ForestMensuration","category":"page"},{"location":"forestmensuration/#Installation","page":"ForestMensuration Package","title":"Installation","text":"","category":"section"},{"location":"forestmensuration/","page":"ForestMensuration Package","title":"ForestMensuration Package","text":"The ForestMensuration package is available through the Julia package system and can be added by running Pkg.add(\"ForestMensuration\") or by directly downloading it from the GitHub page:","category":"page"},{"location":"forestmensuration/","page":"ForestMensuration Package","title":"ForestMensuration Package","text":"pkg> add https://github.com/marcosdanieldasilva/ForestMensuration.jl","category":"page"},{"location":"forestmensuration/#About-the-Author","page":"ForestMensuration Package","title":"About the Author","text":"","category":"section"},{"location":"forestmensuration/","page":"ForestMensuration Package","title":"ForestMensuration Package","text":"I am Marcos Daniel da Silva, a Forest Engineer with a strong interest in forest mensuration and data analysis. I developed the ForestMensuration.jl package as part of my final course project in Forest Engineering at the Federal University of Santa Maria campus Frederico Westphalen (UFSM), under the guidance of Prof. Dr. Rafaelo Balbinot (UFSM) and Prof. Dr. Alexandre Behling (UFPR). This package represents my dedication to providing accessible tools for forestry professionals and researchers, aiming to simplify complex dendrometric calculations and forest inventory analyses using the Julia programming language.","category":"page"},{"location":"forestmensuration/","page":"ForestMensuration Package","title":"ForestMensuration Package","text":"For more details, please feel free to connect with me on LinkedIn or by e-mail: marcosdasilva@5a.tec.br.","category":"page"},{"location":"forestmensuration/","page":"ForestMensuration Package","title":"ForestMensuration Package","text":"This package is supported and encouraged by 5A Inteligência e Engenharia.","category":"page"},{"location":"forestmensuration/","page":"ForestMensuration Package","title":"ForestMensuration Package","text":"You can also access my final course work through the UFSM repository: Forestmensuration.jl: Uma Introdução à Aplicações em Julia.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = ForestMensuration","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Documentation for ForestMensuration.","category":"page"},{"location":"reference/#Reference","page":"API Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [ForestMensuration]\nOrder = [:module, :function, :type, :constant]","category":"page"},{"location":"reference/#ForestMensuration.ForestMensuration","page":"API Reference","title":"ForestMensuration.ForestMensuration","text":"Description:\n\nForestMensuration.jl is a Julia package that provides a comprehensive set of functions for performing dendrometric calculations. Designed with ease of use in mind, the package offers tools that simplify complex forestry calculations, making it straightforward to:\n\nConduct regressions: Easily fit linear models, including transformations and qualitative variables, to find the best relationships in your forestry data.\nCalculate tree and stand volume (cubage): Support for various methods such as Huber, Smalian, and Newton allows precise calculation of tree and stand volumes.\nClassify site productivity: Implement site classification methods to assess the quality and productivity of forest sites.\nCompute dendrometric averages: Calculate essential dendrometric metrics like mean diameter, quadratic mean diameter, and others to understand stand structure.\nCreate frequency tables: Generate frequency and diametric tables to analyze the distribution of dendrometric variables such as diameter and height.\n\nThe package facilitates the analysis of dendrometric and forest data, performs complex calculations with simple commands, and offers a user-friendly and intuitive interface.\n\n\n\n\n\n","category":"module"},{"location":"reference/#ForestMensuration.artificial_form_factor-Tuple{Real, Real, Real}","page":"API Reference","title":"ForestMensuration.artificial_form_factor","text":"artificial_form_factor(vt::Real, ht::Real, dbh::Real)\n\nArtificial Form Factor (aff): For the calculation of the artificial form factor, the volume of the reference cylinder will have a diameter equal to the tree's DBH.\n\naff = Rigorous Vol / Cylinder Vol 1.3\n\nWhere:\n\nRigorous Vol = total volume determined by one of the methods: Smalian, Huber, or Newton;\nCylinder Vol 1.3 = volume of a cylinder with height and diameter equal to the total height and DBH of the tree.\n\nArguments\n\nvt::Real: The total volume of the tree.\nht::Real: The total height of the tree.\ndbh::Real: The diameter at breast height of the tree.\n\nReturns\n\nFloat64: The artificial form factor.\n\nExample\n\njulia> vt = 0.3378;\n\njulia> ht = 18.5;\n\njulia> dbh = 22.7;\n\njulia> artificial_form_factor(vt, ht, dbh)\n0.451176344374475\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.bark_factor-Tuple{Vector{<:Real}, Vector{<:Real}}","page":"API Reference","title":"ForestMensuration.bark_factor","text":"bark_factor(d::Vector{<:Real}, e::Vector{<:Real})\n\nCalculates the bark factor, used to estimate the volume without bark.\n\nThe bark factor is used to estimate the volume without bark by considering the ratio of bark thickness  to total diameter.\n\nArguments\n\nd::Vector{<:Real}: Vector of diameters.\ne::Vector{<:Real}: Vector of bark thicknesses in millimeters.\n\nReturns\n\nFloat64: The bark factor, which represents the proportion of the diameter without bark.\n\nExample\n\njulia> d_values = [30.0, 22.5, 20.2, 15.4, 13.2, 10.9];\njulia> e_values = [1.2, 1.1, 0.85, 0.66, 0.48, 0.0];\njulia> bark_factor(d_values, e_values)\n0.961764705882353\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.basal_area-Tuple{Real}","page":"API Reference","title":"ForestMensuration.basal_area","text":"basal_area(d::Real)\n\nCalculates the basal area (g) of a tree given its diameter in centimeters.\n\nDescription\n\nThis function computes the basal area of a tree, which is the cross-sectional area of the tree trunk at breast height (usually measured at 1.3 meters above ground). Basal area is a critical parameter in forest mensuration, used for estimating stand density, timber volume, and assessing competition among trees in a forest stand.\n\nArguments\n\nd::Real: The diameter at breast height (DBH) of the tree in centimeters. The diameter must be a positive value.\n\nReturns\n\nFloat64: The basal area of the tree in square meters.\n\nExample\n\n# Calculate the basal area for a tree with a diameter of 30 cm\njulia> basal_area(30.0)\n0.07068583470577035\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.bole_volume-Tuple{Type{<:ForestMensuration.CubingMethod}, Vector{<:Real}, Vector{<:Real}}","page":"API Reference","title":"ForestMensuration.bole_volume","text":"bole_volume(method::Type{<:CubingMethod}, h::Vector{<:Real}, d::Vector{<:Real})\n\nCalculate tree bole volume cubic meters using Smalian, Newton, or Huber methods. The methods involve dividing the tree trunk into n sections (logs).  In each section, diameters and lengths are measured at positions that vary according to the technique employed.\n\nArguments\n\nmethod::Type{<:CubingMethod}: The method used for cubing (Smalian, Huber, or Newton).\nh::Vector{<:Real}: Vector of heights.\nd::Vector{<:Real}: Vector of diameters.\n\nReturns\n\nFloat64: The volume of the bole in cubic meters.\n\nExample\n\njulia> d_values = [9.0, 7.0, 5.8, 5.1, 3.8, 1.9, 0.0];\n\njulia> h_values = [0.3, 1.3, 3.3, 5.3, 7.3, 9.3, 10.8];\n\njulia> bole_volume(Smalian, h_values, d_values)\n0.021087744337680632\n\njulia> bole_volume(Huber, h_values, d_values)\n0.020708986073382216\n\njulia> bole_volume(Newton, h_values, d_values)\n0.015548265641391484\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.cone_volume-Tuple{Real, Real}","page":"API Reference","title":"ForestMensuration.cone_volume","text":"cone_volume(h::Real, d::Real)\n\nCalculates the volume of a cone, used to estimate the final portion (vn) of the tree, typically  considered to have a conical shape.\n\nArguments\n\nh::Real: The height of the cone in meters.\nd::Real: The diameter of the cone in centimeters.\n\nReturns\n\nFloat64: The volume of the cone in cubic meters.\n\nExample\n\njulia> cone_volume(18.5, 30.0)\n0.4358959806855838\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.criteria_selection-Tuple{Vector{<:LinearModel}, Vararg{Symbol}}","page":"API Reference","title":"ForestMensuration.criteria_selection","text":"criteria_selection(model::Vector{<:LinearModel}, criteria::Symbol...)\n\nThe criteria_selection function evaluates and ranks a vector of regression models based on specified    criteria, returning the best model according to the combined ranking.\n\nParameters:\n\nmodel::Vector{<:LinearModel}:  A vector of linear regression models to be evaluated and compared.\ncriteria::Symbol...:  A variable number of symbols representing the evaluation criteria to include. Possible values include:\n:adjr2: Adjusted R², a measure of the model's explanatory power, adjusted for the number of predictors.\n:syx: Standard error of the estimate as a percentage of the mean of y.\n:rmse: Root Mean Squared Error, indicating the average magnitude of residuals.\n:mae: Mean Absolute Error, another accuracy measure based on average absolute residuals.\n:aic: Akaike Information Criterion, balancing goodness of fit with model complexity.\n:significance: Evaluates whether model coefficients are statistically significant.\n:normality: Assesses the normality of residuals, an assumption in linear regression.\n:homoscedasticity: Checks for constant variance in residuals, another key regression assumption.\nIf no criteria are specified, the function will use all available criteria by default.\n\nReturns:\n\nLinearModel:  The best model based on the combined ranking of the specified criteria.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.criteria_table-Tuple{Vector{<:LinearModel}, Vararg{Symbol}}","page":"API Reference","title":"ForestMensuration.criteria_table","text":"criteria_table(model::Vector{<:LinearModel}, criteria::Symbol...; best::Union{Bool,Int}=10)\n\nThe criteria_table function evaluates and ranks multiple regression models based on specified criteria.    It generates a comprehensive table of performance metrics for each model, calculates ranks for these      metrics, and combines them into a final score. The function allows for flexible selection of      evaluation criteria and can return either all models or only the top models based on the combined ranking.\n\nParameters:\n\nmodel:  The regression model(s) to be evaluated and compared. This parameter can accept:\nSingle Linear Regression Model (LinearModel): Evaluates a single linear regression model.\nVector of Linear Regression Models (Vector{<:LinearModel}): Evaluates and compares multiple linear regression models.\ncriteria::Symbol...:  A variable number of symbols representing the evaluation criteria to include. Possible values include:\n:r2: R², a measure of the model's explanatory power, representing the proportion of variance in the dependent variable explained by the predictors.\n:adjr2: Adjusted R², a measure of the model's explanatory power, adjusted for the number of predictors.\nd::T: The Willmott’s index of agreement, indicating how closely the predicted values match the observed values.\n:syx: Standard error of the estimate (Syx%) expressed as a percentage of the mean of the dependent \nvariable (y), indicating the precision of the model's predictions.\n:rmse: Root Mean Squared Error, indicating the average magnitude of residuals.\n:mae: Mean Absolute Error, another accuracy measure based on average absolute residuals.\n:aic: Akaike Information Criterion, balancing goodness of fit with model complexity.\n:bic: Bayesian Information Criterion, penalizes model complexity more than AIC;\n:normality: Assesses the normality of residuals using the Kolmogorov-Smirnov test, ensuring that residuals follow a normal distribution.\n:significance: Evaluates whether model coefficients are statistically significant.\n:all: Selects all available criteria for evaluation.\nIf :all is specified, the function will use every available criterion: [:r2, :adjr2, :syx, :rmse, :mae, :aic, :bic, :normality, :significance].  If no criteria are specified, the function defaults to the recommended criteria: [:adjr2, :syx, :aic, :bic, :normality, :significance].\nbest::Union{Bool, Int}=10:  Specifies the number of top models to return based on the combined ranking.\nfalse: Returns the full table with all models ranked.\nInteger value: If less than the total number of models, returns only the top best models.\n\nReturns:\n\nDataFrame:    A sorted table with the evaluated models and their respective metrics. Includes a combined rank    based on the selected criteria.\n\nExamples:\n\nSingle Model:  criteria_table(model, :adjr2, :bic)\nVector of Models: criteria_table([model1, model2], :aic, :mae)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.cubage","page":"API Reference","title":"ForestMensuration.cubage","text":"cubage(method::Type{<:CubingMethod}, h::Vector{<:Real}, d::Vector{<:Real}, \nd_limit::Union{Real,Nothing}=nothing; dbh::Real=1.3)\n\nCalculate tree cubage using Smalian, Newton, or Huber methods. The methods involve dividing the tree trunk into n sections (logs).  In each section, diameters and lengths are measured at positions that vary according to the technique employed.  Thus, the volume of the sections and the total volume are determined by summing the volume of the sections.  Determination can be carried out on felled trees or standing trees using equipment such as the Bitterlich relascope.\n\nArguments\n\nmethod::Type{<:CubingMethod}: The method used for cubing (Smalian, Huber, or Newton).\nh::Vector{<:Real}: Vector of heights.\nd::Vector{<:Real}: Vector of diameters.\nd_limit::Union{Float64, Nothing}: Comercial diameter limit to be used in calculations (optional).\ndbh::Float64: Diameter at breast height (default is 1.3 meters).\n\nReturns\n\nDataFrame: A DataFrame with the calculated volumes and form factors.\n\nExample\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#ForestMensuration.cubage-2","page":"API Reference","title":"ForestMensuration.cubage","text":"cubage(method::Type{<:CubingMethod}, h::Vector{<:Real}, d::Vector{<:Real}, e::Vector{<:Real}, \nd_limit::Union{Real,Nothing}=nothing; dbh::Float64=1.3)\n\nCalculate tree cubage including bark factor. The methods involve dividing the tree trunk into n sections (logs).  In each section, diameters and lengths are measured at positions that vary according to the technique employed.\n\nArguments\n\nmethod::Type{<:CubingMethod}: The method used for cubing (Smalian, Huber, or Newton).\nh::Vector{<:Real}: Vector of heights.\nd::Vector{<:Real}: Vector of diameters.\ne::Vector{<:Real}: Vector of bark thicknesses.\nd_limit::Union{Float64, Nothing}: Comercial diameter limit to be used in calculations (optional).\ndbh::Float64: Diameter at breast height (default is 1.3 meters).\n\nReturns\n\nDataFrame: A DataFrame with the calculated volumes, form factors, and bark-adjusted volumes.\n\nExample\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#ForestMensuration.cubage-3","page":"API Reference","title":"ForestMensuration.cubage","text":"cubage(method::Type{<:CubingMethod}, tree::Symbol, h::Symbol, d::Symbol, e::Symbol, \ndata::AbstractDataFrame, d_limit::Union{Real,Nothing}=nothing; dbh::Float64=1.3)\n\nCalculate tree cubage including bark factor using grouped data from a DataFrame. The methods involve dividing the tree trunk into n sections (logs).  In each section, diameters and lengths are measured at positions that vary according to the technique employed.\n\nArguments\n\nmethod::Type{<:CubingMethod}: The method used for cubing (Smalian, Huber, or Newton).\ntree::Symbol: The symbol representing the tree identifier.\nh::Symbol: The symbol representing the heights in the DataFrame.\nd::Symbol: The symbol representing the diameters in the DataFrame.\ne::Symbol: The symbol representing the bark thicknesses in the DataFrame.\ndata::AbstractDataFrame: The DataFrame containing the tree data.\nd_limit::Union{Float64, Nothing}: Comercial diameter limit to be used in calculations (optional).\ndbh::Float64: Diameter at breast height (default is 1.3 meters).\n\nReturns\n\nDataFrame: A DataFrame with the calculated volumes, form factors, and bark-adjusted volumes for each tree.\n\nExample\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#ForestMensuration.cubage-4","page":"API Reference","title":"ForestMensuration.cubage","text":"cubage(method::Type{<:CubingMethod}, tree::Symbol, h::Symbol, d::Symbol, \ndata::AbstractDataFrame, d_limit::Union{Real,Nothing}=nothing; dbh::Float64=1.3)\n\nCalculate tree cubage using grouped data from a DataFrame. The methods involve dividing the tree trunk into n sections (logs).  In each section, diameters and lengths are measured at positions that vary according to the technique employed.\n\nArguments\n\nmethod::Type{<:CubingMethod}: The method used for cubing (Smalian, Huber, or Newton).\ntree::Symbol: The symbol representing the tree identifier.\nh::Symbol: The symbol representing the heights in the DataFrame.\nd::Symbol: The symbol representing the diameters in the DataFrame.\ndata::AbstractDataFrame: The DataFrame containing the tree data.\nd_limit::Union{Float64, Nothing}: Comercial diameter limit to be used in calculations (optional).\ndbh::Float64: Diameter at breast height (default is 1.3 meters).\n\nReturns\n\nDataFrame: A DataFrame with the calculated volumes and form factors for each tree.\n\nExample\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#ForestMensuration.cylinder_volume-Tuple{Real, Real}","page":"API Reference","title":"ForestMensuration.cylinder_volume","text":"cylinder_volume(h::Real, d::Real)\n\nCalculates the volume of a cylinder, used to estimate the volume (v0) of the tree stump remaining  after clear-cutting.\n\nArguments\n\nh::Real: The height of the cylinder in meters.\nd::Real: The diameter of the cylinder in centimeters.\n\nReturns\n\nFloat64: The volume of the cylinder in cubic meters.\n\nExample\n\njulia> cylinder_volume(18.5, 30.0)\n1.3076879420567515\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.dendrometric_averages-Tuple{LinearModel}","page":"API Reference","title":"ForestMensuration.dendrometric_averages","text":"dendrometric_averages(model::LinearModel; area::Real=1.0)\n\nCalculates various dendrometric averages of a forest stand and estimates the corresponding heights for    each diameter using a regression model.\n\nDescription\n\nThis function computes several dendrometric averages based on a regression model and estimates the heights    associated with each calculated diameter using the provided regression model. These metrics are essential     for forest inventory and management, providing insights into the stand structure, volume estimation,        and growth patterns.\n\nArguments\n\nmodel::LinearModel: A regression model used to predict heights from diameters. The model should be trained with diameters as predictors and heights as the response variable.\narea::Real=1.0: The area in hectares over which the diameters were measured. Default is 1.0 hectare.\n\nReturns\n\nDataFrame: A DataFrame containing the calculated dendrometric averages and the estimated heights. Heights are estimated by applying the regression model to each calculated diameter.\nh₋: Estimated height corresponding to d₋.\nh̄: Estimated height corresponding to d̄.\nhg: Estimated height corresponding to dg.\nhw: Estimated height corresponding to dw,.\nhz: Estimated height corresponding to dz.\nd₁₀₀: Estimated height corresponding to d₁₀₀.\nh₊: Estimated height corresponding to d₊.\n\nExample\n\njulia> using DataFrames\n\n# Assume we have a trained regression model `height_model` that predicts height from diameter\n# Sample data for the regression model\njulia> heights = [8.0, 9.5, 11.0, 12.5, 14.0, 15.5, 17.0, 18.5, 20.0, 21.5];\njulia> diameters = [10.5, 12.0, 13.5, 15.0, 16.5, 18.0, 19.5, 21.0, 22.5, 24.0];\njulia> data = DataFrame(h = heights, d = diameters);\n\n# Fit a linear regression model\njulia> height_models = regression(:h, :d, data);\njulia> best_model = criteria_selection(height_models);\n\n# Calculate dendrometric averages and estimate heights\njulia> dendrometric_averages(best_model; area=0.05)\n1×14 DataFrame\n Row │ d₋       d̅        dg       dw       dz       d₁₀₀     d₊       h₋       h̅        hg       hw       hz       h₊       h₁₀₀\n     │ Float64  Float64  Float64  Float64  Float64  Float64  Float64  Float64  Float64  Float64  Float64  Float64  Float64  Float64\n─────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ 12.7085    17.25  17.7799     18.6  17.2663     21.0  21.7915  10.2085    14.75  15.2799     16.1  14.7663     18.5  19.2915\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.dendrometric_averages-Tuple{Symbol, Symbol, DataFrames.AbstractDataFrame}","page":"API Reference","title":"ForestMensuration.dendrometric_averages","text":"dendrometric_averages(p::Symbol, d::Symbol, data::AbstractDataFrame; area::Real=1.0)\n\nCalculates various dendrometric averages for each group in a dataset, grouping by a specified column,    and using the diameters specified in another column.\n\nDescription\n\nThis function computes several dendrometric averages based on a specified diameter column in a DataFrame,    grouped by another specified column. These metrics are essential for forest inventory and management,    providing insights into the stand structure, volume estimation, and growth patterns for each group.\n\nArguments\n\np::Symbol: The symbol representing the column name in data used to group the data.\nd::Symbol: The symbol representing the column name in data that contains the diameters at breast height (DBH) of the trees in centimeters. All diameters must be positive values.\ndata::AbstractDataFrame: The DataFrame containing the dataset with at least the columns specified by p and d.\narea::Real=1.0: The area in hectares over which the diameters were measured. Default is 1.0 hectare.\n\nReturns\n\nDataFrame: A DataFrame containing the calculated dendrometric averages for each group defined by p.\n\nExample\n\njulia> using DataFrames\n\n# Sample data\njulia> data = DataFrame(\n  species = [\"Oak\", \"Oak\", \"Oak\", \"Pine\", \"Pine\", \"Pine\"],\n  diameter = [10.5, 12.0, 13.5, 15.0, 16.5, 18.0]\n);\n\n# Calculate dendrometric averages grouped by species\njulia> dendrometric_averages(:species, :diameter, data; area=0.05)\n2×8 DataFrame\n Row │ species  d₋       d̅        dg       dw       dz       d₁₀₀     d₊\n     │ String   Float64  Float64  Float64  Float64  Float64  Float64  Float64\n─────┼────────────────────────────────────────────────────────────────────────\n   1 │ Oak         10.5     12.0  12.0623     12.3     12.0      NaN     13.5\n   2 │ Pine        15.0     16.5  16.5454     16.8     16.5      NaN     18.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.dendrometric_averages-Tuple{Vector}","page":"API Reference","title":"ForestMensuration.dendrometric_averages","text":"dendrometric_averages(d::Vector; area::Real=1.0)\n\nCalculates various dendrometric averages of a forest stand, including mean diameter, quadratic mean  diameter, Hohenadl's diameters, Weise's diameter, diameter of the tree with central basal area, and  the mean diameter of the 100 largest trees per hectare.\n\nDescription\n\nThis function computes several dendrometric averages based on a vector of tree diameters. These metrics    are essential for forest inventory and management, providing insights into the stand structure, volume      estimation, and growth patterns.\n\nArguments\n\nd::Vector{<:Real}: A vector of diameters at breast height (DBH) of the trees in centimeters. All diameters must be positive values.\narea::Real=1.0: The area in hectares over which the diameters were measured. Default is 1.0 hectare.\n\nReturns\n\nDataFrame: A DataFrame containing the calculated dendrometric averages:\nd₋: Lower Hohenadl's diameter, calculated as (d̄ - s), where d̄ is the mean diameter and s is the standard deviation. Approximately 16% of the trees have diameters below d₋. This metric represents one standard deviation below the mean diameter and is useful for understanding the variability and distribution of diameters within the stand.\nd̄: Mean diameter, the arithmetic mean of the diameters. It is a basic measure of central tendency but can be influenced by thinning practices. The mean diameter is a fundamental measure but can be significantly affected by the removal of smaller or larger trees during thinning operations.\ndg: Quadratic mean diameter, calculated using the mean basal area as dg = sqrt((40000 * mean(g)) / π), where g is the basal area of each tree. It closely approximates the diameter of the tree with mean basal area and is less affected by extreme values or thinning. This metric provides a better estimate for volume calculations and is less sensitive to variations in the data.\ndw: Weise's diameter, the diameter at which 60% of the trees have smaller diameters (the 60th percentile). It approximates the diameter of the tree with mean volume. Weise's diameter is considered a good approximation of the diameter of the tree with mean volume and is less influenced by thinning practices.\ndz: Diameter of the tree with central basal area, calculated from the median basal area as dz = sqrt((40000 * median(g)) / π). It represents the diameter that divides the stand's total basal area into two equal parts, effectively splitting the cumulative basal area. This metric is less influenced by the removal of smaller trees and provides insight into the stand's structure.\nd₁₀₀: Mean diameter of the 100 largest trees per hectare. If there are fewer than 100 trees per hectare, it returns NaN. This metric provides insight into the size of the largest trees in the stand, which can be important for management objectives like timber production.\nd₊: Upper Hohenadl's diameter, calculated as (d̄ + s). Approximately 84% of the trees have diameters below d₊. This metric represents one standard deviation above the mean diameter and is useful for understanding the variability and distribution of diameters within the stand.\n\nExample\n\njulia> using DataFrames\n\n# Sample diameters in centimeters\njulia> diameters = [10.5, 12.0, 13.5, 15.0, 16.5, 18.0, 19.5, 21.0, 22.5, 24.0];\n\n# Calculate dendrometric averages\njulia> dendrometric_averages(diameters, area=0.05)\n1×7 DataFrame\n Row │ d₋       d̅        dg       dw       dz       d₁₀₀     d₊\n     │ Float64  Float64  Float64  Float64  Float64  Float64  Float64\n─────┼───────────────────────────────────────────────────────────────\n   1 │ 12.7085    17.25  17.7799     18.6  17.2663     21.0  21.7915\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.diametric_table-Tuple{Symbol, Symbol, DataFrames.AbstractDataFrame}","page":"API Reference","title":"ForestMensuration.diametric_table","text":"diametric_table(g::Symbol, d::Symbol, data::AbstractDataFrame; plot_area::Real=1.0)\n\nCreates a diametric table for grouped data in a DataFrame.\n\nArguments\n\ng::S: The symbol representing the grouping variable.\nd::S: The symbol representing the diameter values variable.\ndata::AbstractDataFrame: The DataFrame containing the data.\nplot_area::Real=1.0: The plot area in hectares (default is 1.0).\n\nReturns\n\nDataFrame: A DataFrame containing the diametric table for each group.\n\nExample\n\njulia> using DataFrames\n\n# Define the data'\njulia> diameters = [10.5, 12.0, 13.5, 15.0, 16.5, 18.0, 19.5, 21.0, 22.5, 24.0];\njulia> species = [\"Oak\", \"Oak\", \"Oak\", \"Oak\", \"Oak\", \"Pine\", \"Pine\", \"Pine\", \"Pine\", \"Pine\"];\njulia> data = DataFrame(species=species, diameters=diameters);\n\n# Calculate the diametric table by group with with auto class width and plot area of 0.05 ha (500 m²)\njulia> diametric_table(:species, :diameters, data, plot_area=0.05)\n8×15 DataFrame\n Row │ species  LI       Xi       LS       fi     Fi     fri      Fri      g           ng          ∑ng         fi_ha    Fi_ha    ng_ha     ∑ng_ha   \n     │ String   Float64  Float64  Float64  Int64  Int64  Float64  Float64  Float64     Float64     Float64     Float64  Float64  Float64   Float64\n─────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ Oak         10.0     11.0     12.0      1      1     20.0     20.0  0.00950332  0.00950332  0.00950332     20.0     20.0  0.190066  0.190066\n   2 │ Oak         12.0     13.0     14.0      1      2     20.0     40.0  0.0132732   0.0132732   0.0227765      20.0     40.0  0.265465  0.455531\n   3 │ Oak         14.0     15.0     16.0      1      3     20.0     60.0  0.0176715   0.0176715   0.040448       20.0     60.0  0.353429  0.80896\n   4 │ Oak         16.0     17.0     18.0      2      5     40.0    100.0  0.022698    0.045396    0.085844       40.0    100.0  0.90792   1.71688\n   5 │ Pine        18.0     19.0     20.0      1      1     20.0     20.0  0.0283529   0.0283529   0.0283529      20.0     20.0  0.567057  0.567057\n   6 │ Pine        20.0     21.0     22.0      2      3     40.0     60.0  0.0346361   0.0692721   0.097625       40.0     60.0  1.38544   1.9525\n   7 │ Pine        22.0     23.0     24.0      1      4     20.0     80.0  0.0415476   0.0415476   0.139173       20.0     80.0  0.830951  2.78345\n   8 │ Pine        24.0     25.0     26.0      1      5     20.0    100.0  0.0490874   0.0490874   0.18826        20.0    100.0  0.981748  3.7652\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.diametric_table-Tuple{Symbol, Symbol, Real, DataFrames.AbstractDataFrame}","page":"API Reference","title":"ForestMensuration.diametric_table","text":"diametric_table(g::Symbol, d::Symbol, hi::Real, data::AbstractDataFrame; plot_area::Real=1.0)\n\nCreates a diametric table for grouped data in a DataFrame with a specified class width.\n\nArguments\n\ng::S: The symbol representing the grouping variable.\nd::S: The symbol representing the diameter values variable.\nhi::Real: The class width.\ndata::AbstractDataFrame: The DataFrame containing the data.\nplot_area::Real=1.0: The plot area in hectares (default is 1.0).\n\nReturns\n\nDataFrame: A DataFrame containing the diametric table for each group.\n\nExample\n\njulia> using DataFrames\n\n# Define the data'\njulia> diameters = [10.5, 12.0, 13.5, 15.0, 16.5, 18.0, 19.5, 21.0, 22.5, 24.0];\njulia> species = [\"Oak\", \"Oak\", \"Oak\", \"Oak\", \"Oak\", \"Pine\", \"Pine\", \"Pine\", \"Pine\", \"Pine\"];\njulia> data = DataFrame(species=species, diameters=diameters);\n\n# Calculate the diametric table by group with with The class width of 3 and plot area of 0.05 ha (500 m²)\njulia> diametric_table(:species, :diameters, 3, data, plot_area=0.05)\n6×15 DataFrame\n Row │ species  LI       Xi       LS       fi     Fi     fri      Fri      g          ng         ∑ng        fi_ha    Fi_ha    ng_ha     ∑ng_ha   \n     │ String   Float64  Float64  Float64  Int64  Int64  Float64  Float64  Float64    Float64    Float64    Float64  Float64  Float64   Float64\n─────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ Oak         12.0     13.5     15.0      3      3     60.0     60.0  0.0143139  0.0429416  0.0429416     60.0     60.0  0.858833  0.858833\n   2 │ Oak         15.0     16.5     18.0      1      4     20.0     80.0  0.0213825  0.0213825  0.0643241     20.0     80.0  0.427649  1.28648\n   3 │ Oak         18.0     19.5     21.0      1      5     20.0    100.0  0.0298648  0.0298648  0.0941889     20.0    100.0  0.597295  1.88378\n   4 │ Pine        18.0     19.5     21.0      2      2     40.0     40.0  0.0298648  0.0597295  0.0597295     40.0     40.0  1.19459   1.19459\n   5 │ Pine        21.0     22.5     24.0      1      3     20.0     60.0  0.0397608  0.0397608  0.0994903     20.0     60.0  0.795216  1.98981\n   6 │ Pine        24.0     25.5     27.0      2      5     40.0    100.0  0.0510705  0.102141   0.201631      40.0    100.0  2.04282   4.03263\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.diametric_table-Tuple{Vector{<:Real}, Real}","page":"API Reference","title":"ForestMensuration.diametric_table","text":"diametric_table(d::Vector{<:Real}, hi::Real; plot_area::Real=1.0)\n\nCreates a diametric table for a vector of diameter values given a class width and plot area.\n\nArguments\n\nd::Vector{<:Real}: The vector of diameter values.\nhi::Real: The class width.\nplot_area::Real=1.0: The plot area in hectares (default is 1.0).\n\nReturns\n\nDataFrame: A DataFrame containing the diametric table.\n\nExample\n\n\n# Define the vector of diameter values\njulia> diameters = [10.5, 12.0, 13.5, 15.0, 16.5, 18.0, 19.5, 21.0, 22.5, 24.0];\n\n# Calculate the diametric table with with The class width of 2 and plot area of 0.05 ha (500 m²)\njulia> diametric_table(diameters, 2, plot_area=0.05)\n8×14 DataFrame\n Row │ LI       Xi       LS       fi     Fi     fri      Fri      g           ng          ∑ng         fi_ha    Fi_ha    ng_ha     ∑ng_ha   \n     │ Float64  Float64  Float64  Int64  Int64  Float64  Float64  Float64     Float64     Float64     Float64  Float64  Float64   Float64  \n─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │    10.0     11.0     12.0      1      1     10.0     10.0  0.00950332  0.00950332  0.00950332     20.0     20.0  0.190066  0.190066\n   2 │    12.0     13.0     14.0      1      2     10.0     20.0  0.0132732   0.0132732   0.0227765      20.0     40.0  0.265465  0.455531\n   3 │    14.0     15.0     16.0      1      3     10.0     30.0  0.0176715   0.0176715   0.040448       20.0     60.0  0.353429  0.80896\n   4 │    16.0     17.0     18.0      2      5     20.0     50.0  0.022698    0.045396    0.085844       40.0    100.0  0.90792   1.71688\n   5 │    18.0     19.0     20.0      1      6     10.0     60.0  0.0283529   0.0283529   0.114197       20.0    120.0  0.567057  2.28394\n   6 │    20.0     21.0     22.0      2      8     20.0     80.0  0.0346361   0.0692721   0.183469       40.0    160.0  1.38544   3.66938\n   7 │    22.0     23.0     24.0      1      9     10.0     90.0  0.0415476   0.0415476   0.225017       20.0    180.0  0.830951  4.50033\n   8 │    24.0     25.0     26.0      1     10     10.0    100.0  0.0490874   0.0490874   0.274104       20.0    200.0  0.981748  5.48208\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.diametric_table-Tuple{Vector{<:Real}}","page":"API Reference","title":"ForestMensuration.diametric_table","text":"diametric_table(d::Vector{<:Real}; plot_area::Real=1.0)\n\nCreates a diametric table for a vector of diameter values.\n\nArguments\n\nd::Vector{<:Real}: The vector of diameter values.\nplot_area::Real=1.0: The plot area in hectares (default is 1.0).\n\nReturns\n\nDataFrame: A DataFrame containing the diametric table.\n\nExample\n\n\n# Define the vector of diameter values\njulia> diameters = [10.5, 12.0, 13.5, 15.0, 16.5, 18.0, 19.5, 21.0, 22.5, 24.0];\n\n# Calculate the diametric table with with auto class width and plot area of 0.05 ha (500 m²)\n4×14 DataFrame\n Row │ LI       Xi       LS       fi     Fi     fri      Fri      g          ng         ∑ng        fi_ha    Fi_ha    ng_ha     ∑ng_ha   \n     │ Float64  Float64  Float64  Int64  Int64  Float64  Float64  Float64    Float64    Float64    Float64  Float64  Float64   Float64\n─────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │    10.0     12.5     15.0      2      2     20.0     20.0  0.0122718  0.0245437  0.0245437     40.0     40.0  0.490874  0.490874\n   2 │    15.0     17.5     20.0      3      5     30.0     50.0  0.0240528  0.0721585  0.0967021     60.0    100.0  1.44317   1.93404\n   3 │    20.0     22.5     25.0      4      9     40.0     90.0  0.0397608  0.159043   0.255745      80.0    180.0  3.18086   5.11491\n   4 │    25.0     27.5     30.0      1     10     10.0    100.0  0.0593957  0.0593957  0.315141      20.0    200.0  1.18791   6.30282\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.frequency_table-Tuple{Symbol, Symbol, DataFrames.AbstractDataFrame}","page":"API Reference","title":"ForestMensuration.frequency_table","text":"frequency_table(g::Symbol, x::Symbol, data::AbstractDataFrame)\n\nCreates a frequency table for grouped data in a DataFrame.\n\nArguments\n\ng::S: The symbol representing the grouping variable.\nx::S: The symbol representing the values variable.\ndata::AbstractDataFrame: The DataFrame containing the data.\n\nReturns\n\nDataFrame: A DataFrame containing the frequency table for each group.\n\nExample\n\njulia> using DataFrames\n\n# Define the data'\njulia> diameters = [10.5, 12.0, 13.5, 15.0, 16.5, 18.0, 19.5, 21.0, 22.5, 24.0];\njulia> species = [\"Oak\", \"Oak\", \"Oak\", \"Oak\", \"Oak\", \"Pine\", \"Pine\", \"Pine\", \"Pine\", \"Pine\"];\njulia> data = DataFrame(species=species, diameters=diameters);\n\n# Calculate the frequency table by group with auto class width\njulia> frequency_table(:species, :diameters, data)\n8×8 DataFrame\n Row │ species  LI       Xi       LS       fi     Fi     fri      Fri     \n     │ String   Float64  Float64  Float64  Int64  Int64  Float64  Float64\n─────┼────────────────────────────────────────────────────────────────────\n   1 │ Oak         10.0     11.0     12.0      1      1     20.0     20.0\n   2 │ Oak         12.0     13.0     14.0      1      2     20.0     40.0\n   3 │ Oak         14.0     15.0     16.0      1      3     20.0     60.0\n   4 │ Oak         16.0     17.0     18.0      2      5     40.0    100.0\n   5 │ Pine        18.0     19.0     20.0      1      1     20.0     20.0\n   6 │ Pine        20.0     21.0     22.0      2      3     40.0     60.0\n   7 │ Pine        22.0     23.0     24.0      1      4     20.0     80.0\n   8 │ Pine        24.0     25.0     26.0      1      5     20.0    100.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.frequency_table-Tuple{Symbol, Symbol, Real, DataFrames.AbstractDataFrame}","page":"API Reference","title":"ForestMensuration.frequency_table","text":"frequency_table(g::Symbol, x::Symbol, hi::Real, data::AbstractDataFrame)\n\nCreates a frequency table for grouped data in a DataFrame with a specified class width.\n\nArguments\n\ng::S: The symbol representing the grouping variable.\nx::S: The symbol representing the values variable.\nhi::Real: The class width.\ndata::AbstractDataFrame: The DataFrame containing the data.\n\nReturns\n\nDataFrame: A DataFrame containing the frequency table for each group.\n\nExample\n\njulia> using DataFrames\n\n# Define the data'\njulia> diameters = [10.5, 12.0, 13.5, 15.0, 16.5, 18.0, 19.5, 21.0, 22.5, 24.0];\njulia> species = [\"Oak\", \"Oak\", \"Oak\", \"Oak\", \"Oak\", \"Pine\", \"Pine\", \"Pine\", \"Pine\", \"Pine\"];\njulia> data = DataFrame(species=species, diameters=diameters);\n\n# Calculate the frequency table by group with with The class width of 2\njulia> frequency_table(:species, :diameters, 2, data)\n8×8 DataFrame\n Row │ species  LI       Xi       LS       fi     Fi     fri      Fri     \n     │ String   Float64  Float64  Float64  Int64  Int64  Float64  Float64\n─────┼────────────────────────────────────────────────────────────────────\n   1 │ Oak         10.0     11.0     12.0      1      1     20.0     20.0\n   2 │ Oak         12.0     13.0     14.0      1      2     20.0     40.0\n   3 │ Oak         14.0     15.0     16.0      1      3     20.0     60.0\n   4 │ Oak         16.0     17.0     18.0      2      5     40.0    100.0\n   5 │ Pine        18.0     19.0     20.0      1      1     20.0     20.0\n   6 │ Pine        20.0     21.0     22.0      2      3     40.0     60.0\n   7 │ Pine        22.0     23.0     24.0      1      4     20.0     80.0\n   8 │ Pine        24.0     25.0     26.0      1      5     20.0    100.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.frequency_table-Tuple{Vector{<:Real}, Real}","page":"API Reference","title":"ForestMensuration.frequency_table","text":"frequency_table(x::Vector{<:Real}, hi::Real)\n\nCreates a frequency table for a vector of values given a class width.\n\nArguments\n\nx::Vector{<:Real}: The vector of values.\nhi::Real: The class width.\n\nReturns\n\nDataFrame: A DataFrame containing the frequency table.\n\nExample\n\n\n# Define the vector of values\njulia> x = [10.5, 12.0, 13.5, 15.0, 16.5, 18.0, 19.5, 21.0, 22.5, 24.0];\n\n# Calculate the frequency table with The class width of 2\njulia> frequency_table(x, 2)\n8×7 DataFrame\n Row │ LI       Xi       LS       fi     Fi     fri      Fri     \n     │ Float64  Float64  Float64  Int64  Int64  Float64  Float64\n─────┼───────────────────────────────────────────────────────────\n   1 │    10.0     11.0     12.0      1      1     10.0     10.0\n   2 │    12.0     13.0     14.0      1      2     10.0     20.0\n   3 │    14.0     15.0     16.0      1      3     10.0     30.0\n   4 │    16.0     17.0     18.0      2      5     20.0     50.0\n   5 │    18.0     19.0     20.0      1      6     10.0     60.0\n   6 │    20.0     21.0     22.0      2      8     20.0     80.0\n   7 │    22.0     23.0     24.0      1      9     10.0     90.0\n   8 │    24.0     25.0     26.0      1     10     10.0    100.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.frequency_table-Tuple{Vector{<:Real}}","page":"API Reference","title":"ForestMensuration.frequency_table","text":"frequency_table(x::Vector{<:Real})\n\nCreates a frequency table for a vector of values.\n\nArguments\n\nx::Vector{<:Real}: The vector of values.\n\nReturns\n\nDataFrame: A DataFrame containing the frequency table.\n\nExample\n\n\n# Define the vector of values\njulia> x = [10.5, 12.0, 13.5, 15.0, 16.5, 18.0, 19.5, 21.0, 22.5, 24.0];\n\n# Calculate the frequency table with auto class width\njulia> frequency_table(x)\n4×7 DataFrame\n Row │ LI       Xi       LS       fi     Fi     fri      Fri     \n     │ Float64  Float64  Float64  Int64  Int64  Float64  Float64\n─────┼───────────────────────────────────────────────────────────\n   1 │    10.0     12.5     15.0      2      2     20.0     20.0\n   2 │    15.0     17.5     20.0      3      5     30.0     50.0\n   3 │    20.0     22.5     25.0      4      9     40.0     90.0\n   4 │    25.0     27.5     30.0      1     10     10.0    100.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.goodness_of_fit_test-Tuple{Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}, Vector{<:Real}}","page":"API Reference","title":"ForestMensuration.goodness_of_fit_test","text":"goodness_of_fit_test(dist::ContinuousUnivariateDistribution, x::Vector{<:Real})\n\nPerforms a goodness-of-fit test for the given distribution dist against the observed data x. The function automatically selects the appropriate statistical test based on the characteristics of the data:\n\nAnderson-Darling Test: Used when there are tied values in x.\nKolmogorov-Smirnov Test:\nExact Test: Applied when all values in x are unique and the sample size n is less than 40.\nApproximate Test: Applied when all values in x are unique and the sample size n is 40 or greater.\n\nAfter selecting and performing the appropriate test, the function calculates various evaluation metrics, including p-value, AIC, BIC, RMSE, RME, MAE, and RSE.\n\nArguments\n\ndist: The fitted univariate distribution (e.g., Normal).\nx: A vector of observed data points.\n\nReturns\n\ntest: The goodness-of-fit test.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.hdom_classification-Tuple{LinearModel, DataFrames.AbstractDataFrame, Real, Vector{<:Real}}","page":"API Reference","title":"ForestMensuration.hdom_classification","text":"hdom_classification(model::LinearModel, data_age::AbstractDataFrame, index_age::Real, site::Vector{<:Real})\n\nCalculate the dominant height for each observation given the site classification, a fitted model, and an index age.\n\nDescription:\n\nThe hdom_classification function calculates the dominant height for each observation based on the provided site classification values, using a fitted growth model and the index age. This function essentially works in the reverse direction of site classification; given the site index (site classification) and the ages, it predicts the dominant heights. It is useful for forecasting tree growth and estimating future stand development based on site productivity classes.\n\nDominant Height: The expected average height of the tallest trees in a stand at a given age.\nAge: The current age of the trees for which the dominant height is to be calculated.\nIndex Age: A standard age used as a reference point in the growth model.\nSite Classification (Site Index): Values representing the site productivity class, typically the expected dominant height at the index age.\n\nArguments:\n\nmodel::LinearModel: The fitted regression model relating dominant height to age and site index. This model is used to predict heights based on site classes.\ndata_age::AbstractDataFrame: A DataFrame containing the current age data. It should include an age column representing the ages for which the dominant height is to be calculated.\nindex_age::Real: The index age used in the growth model. It serves as the reference age for site index calculations.\nsite::Vector{<:Real}: A vector containing the site classification values (site indices) for each observation. Each value corresponds to an expected dominant height at the index age.\n\nReturns:\n\nhdom::Vector{Real}: A vector containing the predicted dominant heights for each observation at their respective ages.\n\nExemple\n\njulia> using DataFrames\nusing DataFrames\n\n# Create a DataFrame containing tree plot data\njulia> data = DataFrame(\n    plot = repeat(1:6, inner=5),\n    age = repeat([36, 48, 60, 72, 84], outer=6),\n    h = [13.6, 17.8, 21.5, 21.5, 21.8,\n          14.3, 17.8, 21.0, 21.0, 21.4,\n          14.0, 17.5, 21.2, 21.2, 21.4,\n          13.4, 18.0, 20.8, 20.8, 23.2,\n          13.2, 17.4, 20.3, 20.3, 22.0,\n          13.2, 17.8, 21.3, 21.3, 22.5]\n);\n\n# Perform regression to model the relationship between height (h) and age (age)\n# criteria_selection selects the best regression model based on predefined criteria\njulia> reg = regression(:h, :age, data) |> criteria_selection;\n\n# Define the data set to predict the site classification\njulia> data_to_predict = DataFrame(\n    plot = repeat(7:8, inner=5),\n    age = repeat([36, 48, 60, 72, 84], outer=2),\n    h = [13.1, 17.4, 20.8, 20.8, 22.6,\n          14.3, 17.3, 20.4, 20.4, 20.9]\n);\n\n# Use the selected regression model to classify site quality for each plot\n# at an age of 60 months (5 years). Returns a vector of predicted site classification.\njulia> sites = site_classification(reg, data_to_predict, 60);\n\n# The predicted dominant height for each observation\njulia> hdom_classification(reg, data_to_predict, 60, sites)\n10-element Vector{Float64}:\n 13.1\n 17.4\n 20.8\n 20.9\n 22.7\n 14.3\n 17.3\n 20.4\n 20.4\n 20.9\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.natural_form_factor-Tuple{Real, Real, Vector{<:Real}, Vector{<:Real}}","page":"API Reference","title":"ForestMensuration.natural_form_factor","text":"natural_form_factor(vt::Real, ht::Real, h::Vector{<:Real}, d::Vector{<:Real})\n\nNatural Form Factor (nff): For the calculation of the natural form factor, the volume of the reference cylinder will have a  diameter equal to the diameter taken at 1/10 of the total height.\n\nf0.1h = Rigorous Vol / Cylinder Vol 0.1\n\nWhere:\n\nRigorous Vol = total volume determined by one of the methods: Smalian, Huber, or Newton;\nCylinder Vol 0.1 = volume of a cylinder with height equal to the total height of the tree and diameter taken at 1/10 of the total height. Interpolate diameter at a given height using linear interpolation.\n\nArguments\n\nvt::Real: The total volume of the tree.\nht::Real: The total height of the tree.\nh::Vector{<:Real}: Vector of heights.\nd::Vector{<:Real}: Vector of diameters.\n\nReturns\n\nFloat64: The natural form factor.\n\nExample\n\n\njulia> vt = 0.3378;\n\njulia> ht = 18.5;\n\njulia> d_values = [9.0, 7.0, 5.8, 5.1, 3.8, 1.9, 0.0];\n\njulia> h_values = [0.3, 1.3, 3.3, 5.3, 7.3, 9.3, 10.8];\n\njulia> natural_form_factor(vt, ht, h_values, d_values)\n8.951469588617691\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.plot_regression-Tuple{LinearModel}","page":"API Reference","title":"ForestMensuration.plot_regression","text":"plot_regression(model::LinearModel)\n\nThe plot_regression function generates four essential diagnostic plots to analyze the performance    and validity of a linear regression model in Julia. These plots help in assessing the goodness-of-fit,    the distribution of residuals, and the assumptions underlying linear regression, such as homoscedasticity     and normality. The function is particularly useful for ensuring that the regression model meets the      assumptions required for reliable inference and prediction.\n\nParameters:\n\nmodel::LinearModel:  The fitted linear regression model. This model is analyzed to generate the diagnostic plots.\n\nFunctionality:\n\nObserved vs Fitted Values:   This scatter plot compares the observed data points with the values predicted by the model. It is   useful for visually assessing the accuracy of the model's predictions.\nResiduals vs Fitted Values:   This plot shows the residuals (errors) against the fitted values. Ideally, residuals should be randomly   scattered around zero without any apparent pattern, indicating a good model fit.\nHistogram of Residuals:   This histogram displays the distribution of residuals. A normal distribution of residuals is one of the   key assumptions of linear regression, and this plot helps verify it.\nNormal Q-Q Plot:   This plot compares the quantiles of the residuals to the quantiles of a normal distribution. It is used   to check the assumption of normality in the residuals.\n\nThe function automatically applies color schemes and adjusts plot aesthetics to enhance the clarity of the    visualizations. The plots are combined into a single layout for easy comparison and interpretation.     Additionally, the function adjusts dynamically based on the number of groups in the data, making it     versatile for different datasets and models.\n\nExamples:\n\n# Generate diagnostic plots for a fitted regression model\nplots = plot_regression(model)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.predict!-Tuple{LinearModel, DataFrames.AbstractDataFrame}","page":"API Reference","title":"ForestMensuration.predict!","text":"predict!(model::LinearModel, data::AbstractDataFrame)\n\nThe predict! function computes predictions from a regression model and adds these predictions    directly to the provided data frame as new columns. It is particularly useful in forest inventory    data where not all trees have been measured for a specific variable, allowing the model to estimate      these missing values.\n\nParameters:\n\nmodel::LinearModel: The fitted linear regression model to be evaluated and compared. \ndata: The data frame (AbstractDataFrame) containing the input data. The function will add new columns to this data frame.\n\nFunctionality:\n\nPredicted Values Column (_predict): The function calculates the predicted values for the dependent variable (y) based on the input model    and appends these values as a new column in the data frame with the suffix _predict.\nReal or Estimated Values Column (_real): The function also creates a _real column where the actual measured values of y are preserved if    they exist. For observations where y is missing (or set to 0.0), the predicted value from the    model is used instead.\nThis setup is ideal for forest inventory datasets where certain tree attributes (like height or volume)    might not be measured for every tree, and predictions need to be filled in for these gaps.\n\nExamples:\n\n# Apply predictions to a data frame\npredict!(model, forest_inventory_data)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.predict-Tuple{LinearModel, Any}","page":"API Reference","title":"ForestMensuration.predict","text":"predict(model::LinearModel, data)\n\nPredicts the response variable for a given dataset based on the provided regression model.\n\nArguments:\n\nmodel::LinearModel: The fitted linear regression model to be evaluated and compared.\ndata: A dataset compatible with the Tables.jl interface. Must include the predictors required by the model.\n\nReturns:\n\nPredicted values as a vector. If there are missing values in the predictors, a predict array is returned with missing values handled.\n\nExamples:\n\nSingle Model Prediction:\ny_pred = predict(model, data)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.predict-Tuple{LinearModel}","page":"API Reference","title":"ForestMensuration.predict","text":"predict(model::LinearModel)\n\nThe predict function family provides a versatile way to generate predictions from regression models,    supporting both individual and grouped models. It handles predictions on the original scale even if the    dependent variable (y) has been transformed (e.g., log(y)), ensuring that any transformations     applied during model fitting are correctly reversed, including the application of Meyer correction     factors for logarithmic transformations.\n\nParameters:\n\nmodel:    The regression model(s) to be evaluated and compared. This parameter can accept:\nLinearModel: A single linear regression model.\n\nReturns:\n\nVector{<:Real} or Vector{Union{Missing, <:Real}}: The predicted values on the original scale of y, adjusted for any transformations and corrected using the Meyer factor for logarithmic transformations.\n\nKey Features:\n\nHandles Transformed Dependent Variables: If the dependent variable was transformed (e.g., using log transformations), the function correctly inverts the transformation to return predictions on the original scale.\nApplies Meyer Correction Factor: For models using logarithmic transformations, the Meyer correction factor is applied to the predictions to correct for the bias introduced by the log transformation.\n\nExamples:\n\nSingle Model Prediction:\ny_pred = predict(model)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.quotient_form-Tuple{Real, Real, Vector{<:Real}, Vector{<:Real}}","page":"API Reference","title":"ForestMensuration.quotient_form","text":"quotient_form(ht::Real, dbh::Real, h::Vector{<:Real}, d::Vector{<:Real})\n\nForm Quotient (qf): The natural decrease in diameter along the trunk defines the so-called form quotient, which is a ratio  between diameters. An example of a form quotient is the Schiffel form quotient, given by:\n\nQ = D(1/2H) / DBH\n\nWhere:\n\nQ < 1\nD(1/2H) = diameter measured at half the total height of the tree.\n\nSimilar to the form factor, the volume of a tree, with or without bark, can be obtained by multiplying  the volume of a cylinder by the average form quotient, suitable for the species and the desired volume  to be estimated.\n\nArguments\n\nht::Real: The total height of the tree.\ndbh::Real: The diameter at breast height of the tree.\nh::Vector{<:Real}: Vector of heights.\nd::Vector{<:Real}: Vector of diameters.\n\nReturns\n\nFloat64: The form quotient.\n\nExample\n\n\njulia> ht = 18.5;\n\njulia> dbh = 22.7;\n\njulia> d_values = [9.0, 7.0, 5.8, 5.1, 3.8, 1.9, 0.0];\n\njulia> h_values = [0.3, 1.3, 3.3, 5.3, 7.3, 9.3, 10.8];\n\njulia> quotient_form(ht, dbh, h_values, d_values)\n0.08579295154185025\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.regression-Tuple{Symbol, Symbol, DataFrames.AbstractDataFrame, Vararg{Symbol}}","page":"API Reference","title":"ForestMensuration.regression","text":"regression(y::Symbol, x::Symbol, data::AbstractDataFrame, q::Symbol...)\n\nThe regression function in Julia automatically generates and evaluates multiple simple regression models based on the provided data, including both continuous and categorical variables. This function significantly expands the traditional analysis typically applied in forest biometrics, such as the relationship between tree height and diameter at breast height (DBH), by automatically generating and evaluating 240 unique combinations of dependent and independent variable transformations.\n\nParameters:\n\ny::Symbol: The dependent variable (response variable) for the regression model. Typically represents a continuous measure such as tree height or volume in forestry studies.\nx::Symbol: The independent variable (predictor variable) used to explain variations in the dependent variable. Often represents a measure like diameter at breast height (DBH) in forestry.\ndata::AbstractDataFrame: The dataset containing the variables for regression. The data frame must include all variables specified in y, x, and q, and it will automatically remove any rows with missing values before performing the regression.\nq::Symbol... (optional): A variable number of symbols representing additional categorical variables (qualitative factors) to include in the regression model. These are treated as factors and can influence the model differently based on their levels.\n\nFunctionality:\n\nDependent Variable Transformations: The function generates multiple transformations of the dependent variable (y), including logarithmic and inverse functions. Specifically, the following transformations are created:\nlog(y): Logarithm of y.\nlog_minus(y): Logarithm of y - 1.3.\nlog1p(y): Logarithm of 1 + y.\n1/y: Inverse of y.\n1/(y - 1.3): Inverse of y - 1.3.\n1/√y: Inverse of the square root of y.\n1/√(y - 1.3): Inverse of the square root of y - 1.3.\nx/√y: Ratio of x to the square root of y.\nx/√(y - 1.3): Ratio of x to the square root of y - 1.3.\nx²/y: Square of x divided by y.\nx²/(y - 1.3): Square of x divided by y - 1.3.\nIndependent Variable Transformations: Similarly, multiple transformations of the independent variable (x) are created:\nx²: Square of x.\nlog(x): Logarithm of x.\nlog(x)²: Square of the logarithm of x.\n1/x: Inverse of x.\n1/x²: Inverse of Square of x.\nCombined Model Formulations: The function creates a total of 240 combinations of these transformations by pairing the various forms of y and x. For example, the function considers combinations such as:\ny ~ x + x²\ny ~ x + log(x)\nlog(y) ~ log(x) + 1/x\n(x / y) ~ x + log(x)²\nAnd many more.\n\nThis comprehensive set of models extends beyond the typical scope of forest biometrics, where usually only a few standard models (around five) are tested. By automatically exploring a wide array of potential relationships, this method allows for a more thorough investigation of the possible functional forms that describe the relationship between tree height and DBH or other relevant variables.\n\nStandard Regression: The function performs a regression analysis by automatically generating a wide array of possible models. It creates multiple transformations of the dependent and independent variables, combining them into various model forms. The results can be evaluated, and the best models can be selected based on criteria such as adjusted R², RMSE, AIC, and more, using the criteria_table function.\nQualitative Variables: The function allows the inclusion of categorical variables (q) in the regression model. These variables are automatically treated as factors and can be used to capture variations in the dependent variable that are related to these qualitative factors.\n\nApplications:\n\nThis method is ideal for forestry researchers and practitioners who want to ensure they are not overlooking any potentially significant models by expanding their analysis to include a broader range of possible relationships between the variables.\n\nExamples:\n\n# Perform standard regression without grouping\nmodels = regression(:height, :diameter, data)\n\n# View the top models based on a specific criteria\nbest_models = criteria_table(models, :adjr2, :rmse)\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.residuals-Tuple{LinearModel}","page":"API Reference","title":"ForestMensuration.residuals","text":"residuals(model::LinearModel)\n\nParameters:\n\nmodel::LinearModel: The fitted linear regression model to be evaluated and compared.\n\nReturns\n\nThe residuals, representing the difference between observed and predicted values.\n\nExamples:\n\n# Apply residuals function to a model\nresiduals(model)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.site_classification-Tuple{LinearModel, DataFrames.AbstractDataFrame, Real}","page":"API Reference","title":"ForestMensuration.site_classification","text":"site_classification(model::LinearModel, data_age::AbstractDataFrame, index_age::Real)\n\nCalculate the site classification (site index) for each observation given a fitted model, a table do predict and an index age.\n\nDescription:\n\nSite classification is a method used in forestry to evaluate the productivity and quality of a forest site. It is based on the relationship between the dominant height of trees and their age. By comparing the current dominant height and age of trees to the expected height at a standard reference age (known as the index age), we can classify the site into different productivity classes.\n\nDominant Height: The average height of the tallest trees in a stand, considered indicators of site productivity.\nAge: The current age of the trees in the stand.\nIndex Age: A standard age used for comparison, often corresponding to the rotation age.\n\nBy predicting the dominant height at the index age using a fitted growth model, we obtain the site index. This index reflects the potential height growth of trees on that site and is a key parameter for forest management, aiding in decision-making regarding thinning, harvesting, and sustainability practices.\n\nArguments:\n\nmodel::LinearModel: The fitted regression model that relates dominant height to age. This model is typically derived from empirical data and captures the growth patterns of the species in question.\ndata_age::AbstractDataFrame: A data frame containing the current age data for each observation. It should include an age column representing the age of the trees.\nindex_age::Real: The index age (reference or rotation age) used for site classification. This is the age at which the site index is evaluated and compared.\n\nReturns\n\nsite::Vector{Real}: A vector containing the site classification (site index) for each observation. Each element represents the expected dominant height at the index age, providing a measure of site productivity.\n\nExemple\n\njulia> using DataFrames\nusing DataFrames\n\n# Create a DataFrame containing tree plot data\njulia> data = DataFrame(\n    plot = repeat(1:6, inner=5),\n    age = repeat([36, 48, 60, 72, 84], outer=6),\n    h = [13.6, 17.8, 21.5, 21.5, 21.8,\n          14.3, 17.8, 21.0, 21.0, 21.4,\n          14.0, 17.5, 21.2, 21.2, 21.4,\n          13.4, 18.0, 20.8, 20.8, 23.2,\n          13.2, 17.4, 20.3, 20.3, 22.0,\n          13.2, 17.8, 21.3, 21.3, 22.5]\n);\n\n# Perform regression to model the relationship between height (h) and age (age)\n# criteria_selection selects the best regression model based on predefined criteria\njulia> reg = regression(:h, :age, data) |> criteria_selection;\n\n# Define the data set to predict the site classification\njulia> data_to_predict = DataFrame(\n    plot = repeat(7:8, inner=5),\n    age = repeat([36, 48, 60, 72, 84], outer=2),\n    h = [13.1, 17.4, 20.8, 20.8, 22.6,\n          14.3, 17.3, 20.4, 20.4, 20.9]\n);\n\n# Use the selected regression model to classify site quality for each plot\n# at an age of 60 months (5 years). Returns a vector of predicted site classification.\njulia> site_classification(reg, data_to_predict, 60)\n10-element Vector{Float64}:\n 19.3\n 19.7\n 20.8\n 19.8\n 21.1\n 22.2\n 19.6\n 20.4\n 19.4\n 19.6\n)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.site_classification-Tuple{LinearModel, Real}","page":"API Reference","title":"ForestMensuration.site_classification","text":"site_classification(model::LinearModel, index_age::Real)\n\nCalculate the site classification (site index) for each observation given a fitted model and an index age.\n\nDescription:\n\nSite classification is a method used in forestry to evaluate the productivity and quality of a forest site. It is based on the relationship between the dominant height of trees and their age. By comparing the current dominant height and age of trees to the expected height at a standard reference age (known as the index age), we can classify the site into different productivity classes.\n\nDominant Height: The average height of the tallest trees in a stand, considered indicators of site productivity.\nAge: The current age of the trees in the stand.\nIndex Age: A standard age used for comparison, often corresponding to the rotation age.\n\nBy predicting the dominant height at the index age using a fitted growth model, we obtain the site index. This index reflects the potential height growth of trees on that site and is a key parameter for forest management, aiding in decision-making regarding thinning, harvesting, and sustainability practices.\n\nArguments:\n\nmodel::LinearModel: The fitted regression model that relates dominant height to age. This model is typically derived from empirical data and captures the growth patterns of the species in question.\nindex_age::Real: The index age (reference or rotation age) used for site classification. This is the age at which the site index is evaluated and compared.\n\nReturns\n\nsite::Vector{Real}: A vector containing the site classification (site index) for each observation. Each element represents the expected dominant height at the index age, providing a measure of site productivity.\n\nExemple\n\njulia> using DataFrames\nusing DataFrames\n\n# Create a DataFrame containing tree plot data\njulia> data = DataFrame(\n    plot = repeat(1:6, inner=5),\n    age = repeat([36, 48, 60, 72, 84], outer=6),\n    h = [13.6, 17.8, 21.5, 21.5, 21.8,\n          14.3, 17.8, 21.0, 21.0, 21.4,\n          14.0, 17.5, 21.2, 21.2, 21.4,\n          13.4, 18.0, 20.8, 20.8, 23.2,\n          13.2, 17.4, 20.3, 20.3, 22.0,\n          13.2, 17.8, 21.3, 21.3, 22.5]\n);\n\n# Perform regression to model the relationship between height (h) and age (age)\n# criteria_selection selects the best regression model based on predefined criteria\njulia> reg = regression(:h, :age, data) |> criteria_selection;\n\n# Use the selected regression model to classify site quality for each plot\n# at an age of 60 months (5 years). Returns a vector of predicted site classification.\njulia> site_classification(reg, 60)\n30-element Vector{Float64}:\n 20.5\n 20.3\n 21.5\n 20.4\n 20.4\n 22.2\n 20.3\n 21.0\n 19.9\n 20.0\n 21.4\n 19.9\n 21.2\n 20.1\n 20.0\n 20.0\n 20.5\n 20.8\n 19.8\n 21.6\n 19.5\n 19.7\n 20.3\n 19.3\n 20.5\n 19.5\n 20.3\n 21.3\n 20.2\n 21.0\n)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.site_table-Tuple{LinearModel, Real, Real}","page":"API Reference","title":"ForestMensuration.site_table","text":"site_table(model::LinearModel, index_age::Real)\nsite_table(model::LinearModel, index_age::Real, hi::Real)\n\nCalculate the site table and plot a site graph given a fitted model, index age, and height increment.\n\nDescription:\n\nThe site_table function generates a site table based on a fitted growth model, an index age, and a specified height increment. A site table is a tool used in forestry to estimate the expected dominant height of trees at various ages for different site quality classes. It provides a tabulated representation of height growth over time, allowing foresters to assess site productivity and make informed management decisions.\n\nSite Quality Classes: These are categories that represent different levels of site productivity, typically based on the site index (the expected dominant height at the index age).\nIndex Age: A standard reference age used for site classification and comparison between different sites.\nHeight Increment (hi): The increment by which site index classes are divided. It determines the range and granularity of the site quality classes in the table.\n\nBy using the fitted model to predict dominant heights at various ages and site indices, the site table provides a comprehensive overview of growth patterns across different site qualities.\n\nArguments\n\nmodel::LinearModel: The fitted regression model.\nindex_age::Real: The index age for site classification.\nhi::Real: The height increment for site classification.\n\nReturns\n\nSiteAnalysis: A struct containing a dataFrame containing the site table with predicted dominant heights at various ages for different site index classes and a site plot.\n\nExemple\n\njulia> using DataFrames\nusing DataFrames\n\n# Create a DataFrame containing tree plot data\njulia> data = DataFrame(\n    plot = repeat(1:6, inner=5),\n    age = repeat([36, 48, 60, 72, 84], outer=6),\n    h = [13.6, 17.8, 21.5, 21.5, 21.8,\n          14.3, 17.8, 21.0, 21.0, 21.4,\n          14.0, 17.5, 21.2, 21.2, 21.4,\n          13.4, 18.0, 20.8, 20.8, 23.2,\n          13.2, 17.4, 20.3, 20.3, 22.0,\n          13.2, 17.8, 21.3, 21.3, 22.5]\n);\n\n# Perform regression to model the relationship between height (h) and age (age)\n# criteria_selection selects the best regression model based on predefined criteria\njulia> reg = regression(:h, :age, data) |> criteria_selection;\n\n# Use the selected regression model to generate the site table and site plot\njulia> site_table(reg, 60, 1)\n5×5 DataFrame\n Row │ age      S_19.5   S_20.5   S_21.5   S_22.5  \n     │ Float64  Float64  Float64  Float64  Float64\n─────┼─────────────────────────────────────────────\n   1 │    36.0     13.2     13.6     14.0     14.4\n   2 │    48.0     17.2     18.0     18.7     19.5\n   3 │    60.0     19.5     20.5     21.5     22.5\n   4 │    72.0     20.5     21.6     22.8     23.9\n   5 │    84.0     20.8     22.0     23.1     24.3\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.CubingMethod","page":"API Reference","title":"ForestMensuration.CubingMethod","text":"abstract type CubingMethod\n\nAbstract type representing a method for cubing (calculating volume).\n\nSubtypes\n\nSmalian\nHuber\nNewton\n\n\n\n\n\n","category":"type"},{"location":"reference/#ForestMensuration.Huber","page":"API Reference","title":"ForestMensuration.Huber","text":"abstract type Huber <: CubingMethod\n\nHuber Method:   The Huber method measures the diameter or circumference at the midpoint of the section, and the volume    is determined by:\n\nv = v0 + Σi=1:n(vi) + vt\nvi = gi * li\n\nWhere:\n\nv0 = volume of the stump;\nvi = volume of intermediate sections;\nvt = volume of the cone;\ng = basal area;\nl = length.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ForestMensuration.LinearModel","page":"API Reference","title":"ForestMensuration.LinearModel","text":"struct LinearModel{F<:FormulaTerm,N<:NamedTuple,T<:Float64,B<:Bool}\n\nRepresents a fitted linear model.\n\nFields\n\nformula::F: The formula used to specify the relationship between dependent and independent variables.\ndata::N: The data set (e.g., NamedTuple or DataFrame) containing the variables used in the model.\nβ::Array{T,1}: The estimated regression coefficients (a vector).\nresiduals::Array{T,1}: The residuals, representing the difference between observed and predicted values.\nσ²::T: The variance of residuals, indicating the variability of residuals around the fitted values.\nr²::T: The coefficient of determination (R²), measuring the proportion of variance explained by the model.\nadjr²::T: The adjusted R², adjusted for the number of predictors.\nd::T: The Willmott’s index of agreement, indicating how closely the predicted values match the observed values.\nmse::T: The mean squared error, representing the average squared residual.\nrmse::T: The root mean squared error, a measure of the prediction error.\nsyx::T: The standard error of the estimate (Syx), expressed as a percentage of the mean response.\naic::T: The Akaike Information Criterion, used for model comparison.\nbic::T: The Bayesian Information Criterion, penalizing model complexity more heavily than AIC.\nnormality::B: Boolean flag indicating whether residuals follow a normal distribution (true or false).\nsignificance::B: Boolean flag indicating whether all coefficients are statistically significant (true if all p-values < 0.05).\n\n\n\n\n\n","category":"type"},{"location":"reference/#ForestMensuration.LinearModel-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{F}, Tuple{F, N, Vector{T}, Vector{T}, T, T, T, T, T, T, T, T, T, T, B, B}} where {F, N, T, B}","page":"API Reference","title":"ForestMensuration.LinearModel","text":"LinearModel(formula::F, data::N, β::Array{T,1}, residuals::Array{T,1}, σ²::T, r²::T, adjr²::T, d::T, mse::T, rmse::T, mae::T, syx::T, aic::T, bic::T, normality::B, significance::B)\n\nCreates a new `LinearModel` instance.\n\nArguments\n\nformula::F: The formula used to specify the relationship between dependent and independent variables.\ndata::N: The data set (e.g., NamedTuple or DataFrame) containing the variables used in the model.\nβ::Array{T,1}: The estimated regression coefficients (a vector).\nresiduals::Array{T,1}: The residuals, representing the difference between observed and predicted values.\nσ²::T: The variance of residuals, indicating the variability of residuals around the fitted values.\nr²::T: The coefficient of determination (R²), measuring the proportion of variance explained by the model.\nadjr²::T: The adjusted R², adjusted for the number of predictors.\nd::T: The Willmott’s index of agreement, indicating how closely the predicted values match the observed values.\nmse::T: The mean squared error, representing the average squared residual.\nrmse::T: The root mean squared error, a measure of the prediction error.\nmse::T: The mean absolute error as the average absolute residual value.\nsyx::T: The standard error of the estimate (Syx), expressed as a percentage of the mean response.\naic::T: The Akaike Information Criterion, used for model comparison.\nbic::T: The Bayesian Information Criterion, penalizing model complexity more heavily than AIC.\nnormality::B: Boolean flag indicating whether residuals follow a normal distribution (true or false).\nsignificance::B: Boolean flag indicating whether all coefficients are statistically significant (true if all p-values < 0.05).\n\nReturns\n\nLinearModel{F, N, T, B}: A new fitted linear model instance, encapsulating all model parameters and metrics.\n\nType Parameters\n\nF: The type of the formula term (e.g., FormulaTerm).\nN: The type of the data structure (e.g., NamedTuple).\nT: The numeric type used for calculations (e.g., Float64).\nB: The boolean type (Bool).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ForestMensuration.Newton","page":"API Reference","title":"ForestMensuration.Newton","text":"abstract type Newton <: CubingMethod\n\nNewton Method:   The Newton method involves measuring at 3 positions along each section (at the ends and in the middle    of the logs). Therefore, it is a more laborious method than the others, but the estimated volume will    be more accurate.\n\nv = v0 + Σi=1:n(vi) + vt\nvi = (gi + gm + gi+1)/2 * li\n\nWhere:\n\nv0 = volume of the stump;\nvi = volume of intermediate sections;\nvt = volume of the cone;\ng = basal area;\ngm = basal area at the midpoint of the section;\nl = length.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ForestMensuration.SiteAnalysis","page":"API Reference","title":"ForestMensuration.SiteAnalysis","text":"struct SiteAnalysis\n\nDefine SiteAnalysis struct to store the analysis results\n\nFields\n\nsite_table::DataFrame\nsite_plot::Plots.Plot\n\n\n\n\n\n","category":"type"},{"location":"reference/#ForestMensuration.Smalian","page":"API Reference","title":"ForestMensuration.Smalian","text":"abstract type Smalian <: CubingMethod\n\nSmalian Method:   The Smalian method measures diameters or circumferences at the ends of each section and calculates    the total volume by:\n\nVt = v0 + Σi=1:n(vi) + vt\nv0 = g0 * l0\nvi = (gi + gi+1)/2 * li\nvt = (1/3) * gn * ln\n\nWhere:\n\nv0 = volume of the stump;\nvi = volume of intermediate sections;\nvt = volume of the cone;\ng = basal area;\nl = length.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ForestMensuration.MixTerm","page":"API Reference","title":"ForestMensuration.MixTerm","text":"const MixTerm = Union{AbstractTerm,Tuple{AbstractTerm,Vararg{AbstractTerm}}}\n\nUnion type representing a mixed term, which can be a single AbstractTerm or a tuple of AbstractTerms.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ForestMensuration.β0","page":"API Reference","title":"ForestMensuration.β0","text":"const β0 = InterceptTerm{true}()\n\nRepresents an intercept term for linear models.\n\n\n\n\n\n","category":"constant"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"The following list of references includes the sources consulted and cited during the development of the ForestMensuration.jl package. These works provide theoretical foundations and methodological approaches that support the functions and analyses implemented in the package. Users interested in further exploring topics in forest mensuration, statistical modeling, and programming may find these resources valuable.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Arce, J. E., & Dobner Jr., M. (2024) Manejo e Plajenamento de Florestas Plantadas: com ênfase nos gêneros Pinus e Eucalyptus. Curitiba: Paraná: Ed. dos Autores.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Aguilar, L. J. (2011). Fundamentos de programação: algoritmos, estruturas de dados e objetos (3ª ed.). Porto Alegre: AMGH.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"André, C. M. G., & Regazzi, A. J. (2008). Critérios para seleção de modelos baseados na razão de verossimilhança. UFV, MG. Disponível em: http://arquivo.ufv.br/dbg/resumos2008b/Resumo%20Claudomiro.htm.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Avery, T. E., & Burkhart, H. E. (2001). Forest Measurements (5ª ed.). Nova York: McGraw-Hill Education.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Batista, J. L. F., Couto, H. T. Z. do, & Silva Filho, D. F. da. (2014). Quantificação de recursos florestais: árvores, arvoredos e florestas. São Paulo: Oficina de Textos.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Batista, J. L. F. (2015). Curso Básico de R para Mensuração Florestal: Inventário Florestal. Laboratório de Biometria Ecológica: ESALQ-USP, São Paulo. Disponível em: http://cmq.esalq.usp.br/wiki/doku.php?id=biometria:tutoriais:r-basico-mensuracao","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Bezanson, J., Edelman, A., Karpinski, S., & Shah, V. B. (2017). Julia: A fresh approach to numerical computing. SIAM Review, 59(1), 65-98.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Ghilardi, C. (s.d.). ForestBiometrics.jl. Disponível em: https://github.com/Crghilardi/ForestBiometrics.jl.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Caron, L. T. (1968). An Outline of Forest Mensuration: with Special Reference to Australia. Canberra: Australian National University Press.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Campos, J. C. C., & Leite, H. G. (2009). Mensuração florestal: perguntas e respostas (3ª ed. atualizada e ampliada). Viçosa: Editora UFV.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Cunha, S. D., Guimarães, D. P., & Oliveira, M. F. (2022). Hypsometry and volumetry of Eucalyptus urograndis in a crop-forest integration system. Floresta, 52(1), 159-167.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Devore, J. L. (2006). Probabilidade e estatística para engenharia e ciências (6ª ed.). São Paulo: Pioneira Thomson Learning.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Draper, N. R., & Smith, H. (1998). Applied Regression Analysis (3ª ed.). New York: Wiley.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Fernandes, E. M. G. P. (1999). Estatística Aplicada. Braga: Universidade do Minho.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Ferrari, F., & Chechinel, C. (2008). Introdução a Algoritmos e Programação (v. 2.2). Bagé.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Finger, C. A. G. (2006). Biometria Florestal. Santa Maria: CEPEF; FATEC; UFSM.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Guimarães, I. A. (2008). Estatística – Notas de aula. Universidade Tecnológica Federal do Paraná, Curitiba.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Husch, B., Beers, T. W., & Kershaw Jr, J. A. (2003). Forest Mensuration (4ª ed.). New York: Wiley.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Júnior, P. J. R. (2008). CE-223: Estatística Computacional, Laboratório de Estatística e Geoinformação, UFPR, Paraná. Disponível em: http://leg.ufpr.br/~paulojus/ce223/ce223/ce223se19.html.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"JuliaLang. (s.d.). Julia 1.11 Documentation. Disponível em: https://docs.julialang.org/en/v1/.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"JuliaPackages. (s.d.). Pacotes Julia. Disponível em: https://juliapackages.com/packages.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Kutner, M. H., Nachtsheim, C. J., Neter, J., & Li, W. (2005). Applied Linear Statistical Models (5ª ed.). New York: McGraw-Hill/Irwin.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Machado, S. A., & Figueiredo Filho, A. (2003). Dendrometria. Curitiba: Editado pelos autores.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Magalhães, J. W. S., Ávalos, J. B., & Santos, L. J. A. (2017). Dossiê da Linguagem Julia (1ª ed.). Viçosa: UFV.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Mariano, M. V., Lauricel, C. M., & Frugoli, A. D. (2006). Estatística Indutiva: Teoria, Exercícios Resolvidos Tarefas.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Martins, J. F. C., Machado, S. A., & Gaspar, R. O. (2021). Modelagem hipsométrica de povoamentos de Acácia Negra usando linguagem de programação Julia. BIOFIX Scientific Journal, 6(2), 133-152.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"McNicholas, P. D., & Tait, P. A. (2019). Data Science with Julia: Fundamentals for Data Science, Machine Learning and Artificial Intelligence. Suíça: Springer.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Naghettini, M., & Pinto, É. J. A. (2007). Hidrologia estatística. Belo Horizonte: CPRM.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Klok, H., & Nazarathy, Y. (2019). Statistics with Julia: Fundamentals for Data Science, Machine Learning and Artificial Intelligence. Suíça: Springer.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Prodan, M., Peters, R., Cox, F., & Real, P. (1997). Mensura Forestal. San José: IICA.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Sanquetta, C. R., Behling, A., Dalla Corte, A. P., & Netto, S. P. (2014). Inventários florestais: planejamento e execução (3ª ed.). Curitiba: Multi-Graphic Gráfica e Editora.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Sanquetta, C. R., Behling, A., Dalla Corte, A. P., & Netto, S. P. (2018). Selection criteria for linear regression models to estimate individual tree biomasses in the Atlantic rain forest, Brazil. Carbon Balance and Management, 13(25).","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Schneider, P. R. (1993). Introdução ao manejo florestal. Santa Maria: Ed. UFSM.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Schneider, P. R. (1998). Análise de regressão aplicada à Engenharia Florestal (2ª ed.). Santa Maria: UFSM, CEPEF.","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Weisberg, S. (2014). Applied Linear Regression (4ª ed.). Nova Jersey: John Wiley & Sons, Inc.","category":"page"},{"location":"#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Pages = [\"reference.md\"]\nOrder = [:module, :function, :type, :constant]","category":"page"},{"location":"tutorial/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"tutorial/#Computing-the-Cubage","page":"Getting Started","title":"Computing the Cubage","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"The cubage function calculates the volume of a tree (cubage) using different cubing methods. It can handle both single trees and multiple trees in a dataset. The available cubing methods are Smalian, Newton and Huber.","category":"page"},{"location":"tutorial/#Cubing-a-Simple-Tree","page":"Getting Started","title":"Cubing a Simple Tree","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"When cubing a single tree, you need to provide vectors of diameters (d) and heights (h) measured at different points along the tree stem. Diameters should be in centimeters, and heights should be in meters. The diameter at breast height (DBH) and total tree height (Ht) are essential inputs.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"using ForestMensuration\n\n# Diameters at different heights (cm)\nd = [9.0, 7.0, 5.8, 5.1, 3.8, 1.9, 0.0]\n\n# Corresponding heights (m)\nh =  [0.3, 1.3, 3.3, 5.3, 7.3, 9.3, 10.8]\n\n# Calculate cubage using the Smalian method\ncubage(Smalian, h, d)","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"\n","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"vt: Total volume\nv0: Volume of the stump\nvc: Commercial bole volume\nvr: Residual volume above commercial limit\nvn: Volume of the top (cone)\ndbh: Diameter at breast height\nht: Total tree height\nhc: Commercial height\naff: Artificial form factor\nnff: Natural form factor\nqf: Form quotient","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"\n","category":"page"},{"location":"tutorial/#Including-Bark-Thickness","page":"Getting Started","title":"Including Bark Thickness","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"With the bark thickness value, it is possible to calculate the bark factor and total and commercial volumes without bark. Note: the provided thickness should be the 'single thickness' in centimeters. The function will convert it into 'double thickness'.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Bark thickness at corresponding heights (cm)\nbark = [0.9, 0.5, 0.3, 0.2, 0.2, 0.1, 0.0]\n\n# Define a commercial diameter limit\ndiameter_limit = 4.0\n\n# Calculate cubage using the Newton method, including bark thickness and diameter limit\ncubage(Newton, h, d, bark, diameter_limit)","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"\n Additional columns include:","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"k: Bark factor\n: vtwb, v0wb, vcwb, vrwb, vnwb: Corresponding volumes without bark","category":"page"},{"location":"tutorial/#Cubing-Multiple-Trees","page":"Getting Started","title":"Cubing Multiple Trees","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"To calculate cubage for multiple trees, organize your data in a DataFrame with columns for tree identifiers, heights, diameters, and optionally bark thickness.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"using ForestMensuration\nusing DataFrames\n\n# Sample data for multiple trees\ndata = DataFrame(\n    tree = [148, 148, 148, 148, 148, 148, 148, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222],\n    h = [0.3, 1.3, 3.3, 5.3, 7.3, 9.3, 10.8, 0.3, 1.3, 3.3, 5.3, 7.3, 9.3, 11.3, 13.3, 15.3, 17.3, 19.5],\n    d = [9.0, 7.0, 5.8, 5.1, 3.8, 1.9, 0.0, 16.0, 12.0, 11.6, 10.1, 9.4, 8.2, 7.0, 6.0, 4.0, 2.0, 0.0],\n    bark = [0.9, 0.5, 0.3, 0.2, 0.2, 0.1, 0.0, 1.2, 0.5, 0.3, 0.3, 0.2, 0.2, 0.3, 0.0, 0.0, 0.0, 0.0]\n)\n\n# Define a commercial diameter limit\ndiameter_limit = 2.5\n\n# Calculate cubage for each tree using the Huber method\ncubage(Huber, :tree, :h, :d, data, diameter_limit)","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"\n","category":"page"},{"location":"tutorial/#Including-Bark-Thickness-for-Multiple-Trees","page":"Getting Started","title":"Including Bark Thickness for Multiple Trees","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"Additionally, bark thickness values can be provided to calculate bark factors and volumes without bark.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Calculate cubage including bark thickness\ncubage(Huber, :tree, :h, :d, :bark, data, diameter_limit)","category":"page"},{"location":"tutorial/#Fitting-Linear-Regressions","page":"Getting Started","title":"Fitting Linear Regressions","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"The regression function automatically generates and evaluates multiple regression models based on the provided data. It explores various transformations of the dependent and independent variables, creating a comprehensive set of models for analysis.","category":"page"},{"location":"tutorial/#Adjusting-a-Hypsometric-Relationship","page":"Getting Started","title":"Adjusting a Hypsometric Relationship","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"In forestry, hypsometric relationships model the relationship between tree height (h) and diameter at breast height (dbh). The regression function generates numerous models to find the best fit.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"using ForestMensuration\nusing DataFrames\n\n# Sample dataset with tree heights and diameters\ndata = DataFrame(\n    plot = [\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\",\n            \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\",\n            \"C\", \"C\", \"C\", \"C\", \"C\", \"C\", \"C\", \"C\", \"C\", \"C\", \"C\", \"C\",\n            \"D\", \"D\", \"D\", \"D\", \"D\", \"D\", \"D\", \"D\", \"D\", \"D\", \"D\", \"D\", \"D\", \"D\", \"D\"],\n    h = [20.9, 19.6, 13.2, 23.3, 19.2, 16.2, 8.3, 19.7, 11.0, 24.0, 25.8, 28.2, 24.2, 26.2, 28.3,\n         14.4, 14.9, 15.6, 8.2, 22.1, 16.7, 22.3, 19.5, 15.9, 16.7, 24.5, 21.7, 23.8,\n         20.8, 17.7, 19.3, 16.7, 22.2, 18.6, 6.9, 22.3, 8.7, 22.1, 21.0, 23.5,\n         19.5, 19.7, 18.2, 13.9, 12.3, 14.5, 12.3, 18.6, 18.0, 17.4, 24.3, 22.8, 23.2, 23.5, 25.2],\n    dbh = [31.5, 30.0, 26.5, 31.0, 29.0, 26.5, 14.5, 28.8, 19.0, 31.5, 32.5, 33.8, 32.5, 33.3, 36.0,\n           24.0, 28.0, 23.0, 15.5, 31.0, 27.0, 29.0, 28.0, 26.0, 29.0, 30.0, 29.0, 30.5,\n           25.0, 26.8, 27.5, 26.0, 26.0, 25.8, 10.8, 27.0, 16.5, 26.5, 27.0, 26.3,\n           26.0, 25.5, 25.0, 23.5, 22.0, 23.0, 23.0, 26.0, 25.5, 27.5, 26.5, 26.5, 27.8, 26.0, 27.0]\n)\n\n# Perform regression analysis between height and diameter\nmodels = regression(:h, :dbh, data)","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"This generates 240 different models combining various transformations of h and dbh.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"#number of fitted regressions\nlength(models)","category":"page"},{"location":"tutorial/#Regression-Selection-Criteria","page":"Getting Started","title":"Regression Selection Criteria","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"After fitting the models, you can evaluate and rank them based on specific criteria using the criteria_table function.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Evaluate models\nbest_models = criteria_table(models)","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Evaluate models based on Adjusted R², Standard Error and chosing the 5 bests\nbest_5_models = criteria_table(models, :adjr2, :syx, best=5)","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"\n","category":"page"},{"location":"tutorial/#Selecting-the-Best-Model","page":"Getting Started","title":"Selecting the Best Model","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"To select the best model based on the combined ranking you can simply use the criteria_selection function:","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Select the top model\ntop_model = criteria_selection(models)","category":"page"},{"location":"tutorial/#Plotting-the-Regression","page":"Getting Started","title":"Plotting the Regression","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"You can visualize the regression model using the plot_regression function.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Plot the top model\nplot_regression(top_model)","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"\n","category":"page"},{"location":"tutorial/#Predict","page":"Getting Started","title":"Predict","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"The predict function. allows you to generate predicted values from a regression model on the original scale of the dependent variable. This is particularly useful when the model involves transformations of the dependent variable (e.g., logarithmic transformations). The function automatically applies the appropriate inverse transformations and corrections, such as the Meyer correction factor for logarithmic models.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Returns the predicted values from the model on the original scale\nh_pred = predict(top_model)","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"The predict! function extends this by adding the predicted values directly to your DataFrame. It creates new columns for the predicted and actual values, combining observed measurements with model predictions where data may be missing. This is especially useful in forest inventory datasets where certain tree attributes might not be measured for every tree, and predictions need to be filled in for these gaps.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Automatically adds predicted and actual height columns to the provided DataFrame.\n# This combines observed heights and predicted heights for trees with missing or unmeasured heights.\npredict!(top_model, data)\n\n# Firsts values of dataset\nprintln(data[1:10, :])","category":"page"},{"location":"tutorial/#Adjusting-a-Qualitative-(Dummy)-Hypsometric-Relationship","page":"Getting Started","title":"Adjusting a Qualitative (Dummy) Hypsometric Relationship","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"If your data includes categorical variables (e.g., different plots or species), you can include them in the regression analysis.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Perform regression including 'plot' as a categorical variable\nqualitative_models = regression(:h, :dbh, data, :plot)\n\n# Select the best model\ntop_qual_model = criteria_selection(qualitative_models, :adjr2, :syx, :aic)","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"\n","category":"page"},{"location":"tutorial/#Plotting-the-Qualitative-Regression","page":"Getting Started","title":"Plotting the Qualitative Regression","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Plot the top qualy model\nplot_regression(top_qual_model)","category":"page"},{"location":"tutorial/#Site-Classification","page":"Getting Started","title":"Site Classification","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"The site classification enable you to evaluate and classify forest sites based on regression models relating tree height and age. These functions are particularly useful for assessing site productivity and quality by comparing observed data with expected values derived from well-calibrated models.","category":"page"},{"location":"tutorial/#Calculating-Site-Classification","page":"Getting Started","title":"Calculating Site Classification","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"The site_classification function calculates the expected dominant height at a given index age for each observation based on a fitted regression model. This is a key step in classifying the productivity of a forest site.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"using ForestMensuration, DataFrames\n\n# Create a DataFrame containing tree plot data\ndata = DataFrame(\n    plot = repeat(1:6, inner=5),\n    age  = repeat([36, 48, 60, 72, 84], outer=6),\n    h    = [13.6, 17.8, 21.5, 21.5, 21.8,\n            14.3, 17.8, 21.0, 21.0, 21.4,\n            14.0, 17.5, 21.2, 21.2, 21.4,\n            13.4, 18.0, 20.8, 20.8, 23.2,\n            13.2, 17.4, 20.3, 20.3, 22.0,\n            13.2, 17.8, 21.3, 21.3, 22.5]\n)\n\n# Fit a regression model to relate height (h) to age\nreg = regression(:h, :age, data) |> criteria_selection\n\n# Define the target index age (for example, 60 months)\nindex_age = 60\n\n# Calculate the site classification values (site indices) for each observation\nsite_indices = site_classification(reg, data, index_age)\n\nprintln(\"Site Classification Values:\")\nprintln(site_indices)","category":"page"},{"location":"tutorial/#Calculating-Dominant-Height-Classification","page":"Getting Started","title":"Calculating Dominant Height Classification","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"The hdom_classification function uses the site classification values to predict the dominant height for each observation at the specified index age. This reverses the site classification process, allowing you to forecast tree heights based on site productivity.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Now, compute the dominant heights for each observation using the site indices\ndominant_heights = hdom_classification(reg, data, index_age, site_indices)\n\nprintln(\"Dominant Height Values:\")\nprintln(dominant_heights)","category":"page"},{"location":"tutorial/#Generating-a-Site-Table","page":"Getting Started","title":"Generating a Site Table","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"The site_table function creates a comprehensive site table and an associated site plot. This table shows the predicted dominant heights at various ages for different site index classes. You can specify a height increment (hi) to define the granularity of the site classes.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Generate the site table\nanalysis = site_table(reg, index_age)","category":"page"},{"location":"tutorial/#Plotting-the-Site-Index","page":"Getting Started","title":"Plotting the Site Index","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Generate site plot\nanalysis.site_plot","category":"page"},{"location":"tutorial/#Frequency-and-Statistical-Functions","page":"Getting Started","title":"Frequency and Statistical Functions","text":"","category":"section"},{"location":"tutorial/#Creating-Frequency-Tables","page":"Getting Started","title":"Creating Frequency Tables","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"The frequency_table function creates frequency distributions for a vector of values, which is useful for analyzing the distribution of diameters or heights in your data.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Frequency table for diameters using Sturges' formula for class intervals\nfrequency_table(data.dbh)","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"\n","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"LI: Lower class limit\nXi: Class center\nLS: Upper class limit\nfi: Frequency count\nFi: Cumulative frequency\nfri: Relative frequency (%)\nFri: Cumulative relative frequency (%)","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"\n","category":"page"},{"location":"tutorial/#Specifying-Class-Width","page":"Getting Started","title":"Specifying Class Width","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"You can specify the class width (hi) to customize the intervals.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Frequency table for heights with class width of 4 meters\nfrequency_table(data.h, 4)","category":"page"},{"location":"tutorial/#Calculating-Dendrometric-Averages","page":"Getting Started","title":"Calculating Dendrometric Averages","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"he dendrometric_averages function computes various dendrometric averages of a forest stand, providing insights into the stand structure and growth patterns.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Calculate dendrometric averages for the dataset\ndendrometric_averages(data.dbh, area=0.05)","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"\n","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"d₋: Lower Hohenadl's diameter\nd̄: Mean diameter\ndg: Quadratic mean diameter\ndw: Weise's diameter (60th percentile)\ndz: Diameter of the tree with central basal area\nd₁₀₀: Mean diameter of the 100 largest trees per hectare (returns NaN if fewer than 100 trees)\nd₊: Upper Hohenadl's diameter","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"\n","category":"page"},{"location":"tutorial/#Estimating-Heights-Using-a-Regression-Model","page":"Getting Started","title":"Estimating Heights Using a Regression Model","text":"","category":"section"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"If you have a regression model (e.g., top_model from earlier), you can estimate the corresponding heights for each calculated diameter.","category":"page"},{"location":"tutorial/","page":"Getting Started","title":"Getting Started","text":"# Estimate heights for dendrometric averages using the regression model\ndendrometric_averages(top_model, area=0.05)","category":"page"}]
}
